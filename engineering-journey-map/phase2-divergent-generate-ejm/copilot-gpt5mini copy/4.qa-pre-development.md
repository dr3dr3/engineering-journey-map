# 4. QA Pre-Development

## Journey Step Focus
- How do we plan testing to validate acceptance and non-functional needs?
- How do we design automated tests and test data strategies?
- How do we prepare environments and test harnesses early?

## Actions
- Define test strategy: unit, integration, e2e, load, and chaos
- Create test cases aligned to acceptance criteria
- Provision test environments and seed data strategies
- Include observability checks and synthetic tests
- Identify test automation ownership and CI gates

## Challenges
- Environment parity between dev, staging, and prod
- Long-running or unreliable integration tests
- Test data privacy and management constraints
- Missing performance or resilience testing plans

## Interactions
- QA/Test Engineers: define coverage and automation plan
- Platform: reserve and provision test environments
- Developers: collaborate on test hooks and mocks
- Security/Compliance: ensure test data handling meets policies

## Touchpoints
- **Test Management**: test plans, coverage reports, and dashboards
- **CI/CD**: test runners, flakes handling, and parallelization
- **Sandbox/Stage**: environment templates and teardown processes
- **Synthetic Monitoring**: pre-prod checks and canary pipelines

## Feeling
- 🧪 Confident — when tests map to acceptance criteria
- 😬 Frustrated — when tests are flaky or slow
- 🔁 Reassured — when CI gives fast, reliable feedback

## Opportunities
- Shift-left testing: embed testability hooks and contract tests
- Invest in test data management and ephemeral environments
- Track and reduce test flakiness with triage and analytics

## Potential for AI
- **Test Case Generator**: generate edge-case tests from acceptance criteria.
- **Flaky Test Detector**: analyze CI history to prioritize flake fixes.
